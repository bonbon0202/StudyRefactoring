---
sidebar_label: "2. 코드에서 나는 악취"
sidebar_position: 2
---

# 코드에서 나는 악취

:::caution

**냄새 나면 당장 갈아라** - 켄트 백 할머니의 육아 원칙.

:::

## 3.1 기이한 이름

이름 짓기는 프로그래밍에서 가장 어렵기로 손꼽히는 두 가지(캐시 무효화, 이름 짓기) 중 하나이다.
마땅한 이름이 떠오르지 않는다면 설계에 더 근본적인 문제가 숨어있을 가능성이 높다.
그래서 혼란스러운 이름을 잘 정리하다 보면 코드가 훨씬 간결해질 때가 많다.

## 3.2 중복 코드

가장 간단한 중복 코드의 예로, 한 클래스에 딸린 두 메서드가 똑같은 표현식을 사용하는 경우가 있다.
이럴때는 **함수 추출하기**를 써서 양쪽 모두 추출된 메서드를 호출하게 바꾸면 된다.
코드가 비슷한데 완전히 똑같지는 않다면, 먼저 **문장 슬라이드하기** 로 비슷한 부분을 한 곳에 모아 함수 추출하기를 더 쉽게 적용할 수 있는지 살펴본다.

```js title="login.js"
// 함수 중복코드 예시
document.getElementById("user-id").addEventListener("keyup", (e) => {
  const userId = document.getElementById("user-id").value;
  const userPw = document.getElementById("user-pw").value;

  if (userId && userPw) {
    loginBtn.classList.add("actived");
    if (e.code === "Enter") {
      success();
    }
  } else {
    loginBtn.classList.remove("actived");
  }
});

document.getElementById("user-pw").addEventListener("keyup", (e) => {
  const userId = document.getElementById("user-id").value;
  const userPw = document.getElementById("user-pw").value;

  if (userId && userPw) {
    loginBtn.classList.add("actived");
    if (e.code === "Enter") {
      success();
    }
  } else {
    loginBtn.classList.remove("actived");
  }
});
```

```js title="login.js"
// 함수 중복코드 수정
const Id = document.getElementById("user-id");
const Pw = document.getElementById("user-pw");

function activateLoginButton(e) {
  const userId = document.getElementById("user-id").value;
  const userPw = document.getElementById("user-pw").value;

  if (userId && userPw) {
    loginBtn.classList.add("actived");
    if (e.code === "Enter") {
      success();
    }
  } else {
    loginBtn.classList.remove("actived");
  }
}

Id.addEventListener("keyup", activateLoginButton);
Pw.addEventListener("keyup", activateLoginButton);
```

## 3.3 긴 함수

우리의 경험에 비춰보면 오랜 기간 잘 활용되는 프로그램들은 하나 같이 짧은 함수로 구성됐다.
짧은 함수로 구성된 코드를 이해하기 쉽게 만드는 가장 확실한 방법은 좋은 이름이다. 함수 이름을 잘 지어두면 본문 코드를 볼 이유가 사라진다.
그러기 위해서는 훨씬 적극적으로 함수를 쪼개야 한다. 심지어 원래 코드보다 길어지더라도 함수로 뽑는다.
함수 이름은 **동작 방식이 아닌 의도'intention'**가 드러나게 짓는다.

함수가 매개 변수와 임시 변수를 많이 사용한다면 추출 작업에 방해가 된다.
이런 상황에서 함수를 추출하다 보면 추출된 함수에도 매개 변수가 너무 많아져서 리팩터링 전보다 난해해질 수 있다.
**임시 변수를 질의 함수로 바꾸기**로 임시 변수의 수를, **매개 변수 객체 만들기**와 **객체 통째로 넘기기**로는 매개 변수의 수를 줄일 수 있다.

조건문은 **조건문 분해하기**로 대응하고 거대한 switch 문을 구성하는 case문마다 **함수 추출하기**를 적용해서 각 case의 본문을 함수 호출문 하나로 바꾼다.
반복문도 그 안의 코드와 함께 추출해 독립된 함수로 만들되, 적합한 이름이 떠오르지 않는다면 성격이 다른 작업이 섞여 있기 떄문일 수 있다.
과감히 **반복문 쪼개기** 를 적용해 작업을 분리한다.

## 3.4 긴 매개변수 목록

매개 변수 목록이 길어지면 그 자체로 이해하기 어려울 떄가 많이 있다.
**매개변수를 질의 함수로 바꾸기** - 종종 다른 매개 변수에서 값을 얻어 올 수 있는 매개변수가 있을 수 있는데, 이런 매개변수는 질의함수로 바꾸어 제거할 수 있다.
**객체 통째로 넘기기** - 사용중인 데이터 구조에서 값들을 뽑아 각각을 별개의 매개변수로 전달하는 코드라면 해당 방법을 이용하자.
**매개변수 객체 만들기** - 항상 함께 전달되는 매개변수들은 하나로 묶어 버린다.
**플래그 인수 제거하기** - 함수의 동작 방식을 정하는 플래그 역할의 매개변수는 해당 방식으로 없애준다.
**여러 함수를 클래스로 묶기** - 여러 개의 함수가 특정 매개 변수들의 값을 공통으로 사용할 때 유용하다.

## 3.5 전역 데이터

전역 데이터는 코드 베이스 어디에서든 건드릴 수 있고 값을 누가 바꿨는지 찾아낼 매커니즘이 없다는 게 문제다. 그래서 마치 '유령같은 원격작용'처럼 버그가 끊임없이 발생한다.
이를 방지하기 위해 사용하는 대표적인 리팩터링은 **변수 캡슐화하기**이다. 이런 데이터를 함수로 감싸는 것 만으로도 데이터를 수정하는 부분을 쉽게 찾을 수 있고 접근을 통제할 수 있게 된다.

## 3.6 가변 데이터(Mutable Data)

데이터를 변경했더니 예상치 못한 결과나 골치 아픈 버그로 이어지는 경우가 종종 있다.
무분별한 데이터 수정에 따른 위험을 줄이는 방법은 얼마든지 있다.
**변수 캡슐화하기** - 정해놓은 함수를 거쳐야만 값을 수정할 수 있또록 하면 값이 어떻게 수정되는지 감시하거나 코드를 개선하기 쉽다.
**변수 쪼개기** - 하나의 변수가 용도가 다른 값들을 저장하느라 값을 갱신하는 경우라면 이를 이용해 용도별로 독립 변수에 저장하게 하여 값 갱신이 문제를 일이킬 여지를 없앤다.
**질의 함수와 변경 함수 분리하기** - API를 만들 때는 이를 활용해 꼭 필요한 경우가 아니라면 부작용이 있는 코드를 호출할 수 없게 한다.

변수의 유효범위가 넓어진다면, 덩달아 위험도 커진다.
**여러 함수를 클래스로 묶기, 여러 함수를 변환함수로 묶기**를 활용해 변수를 갱신하는 코드들의 유효범위를 제한한다.

## 3.7 뒤엉킨 변경

뒤엉킨 변경은 단일 책임 원칙 (Single Responsibility Principle)이 제대로 지켜지지 않을 때 나타단다.
즉, 하나의 모듈이 서로 다른 이유들로 인해 여러 가지 방식으로 변경되는 일이 많을 때 발생한다.
(지원해야할 db가 추가 될 때마다 함수 세 개를 바꾸어야 하는 등)

## 3.8 산탄총 수술 (Shotgun Surgery)

산탄총 수술은 뒤엉킨 변경과 비슷하면서도 정 반대이다.

|                 | 뒤엉킨 변경           | 산탄총 수술             |
| --------------- | --------------------- | ----------------------- |
| 원인            |                       | 맥락을 잘 구분하지 못함 |
| 해법(원리)      |                       | 맥락을 정확히 구분      |
| 발생 과정(현상) | 한 코드에 섞여 들어감 | 여러 코드에 흩뿌려짐    |
| 해법(실제행동)  | 맥락별로 분리         | 맥락별로 모음           |

이 냄새는 코드를 변경할 떄마다 자잘하게 수정해야 하는 클레스가 많을 때 풍긴다.

- 함꼐 변경되는 대상들을 **함수 옮기기**, **필드 옮기기**로 모두 한 모듈에 묶어 두면 좋다.
- 비슷한 데이터를 다루는 함수가 많다면 **여러 함수를 클래스로 묶기** 를 적용한다.

## 3.9 기능편애

프로그램을 모듈화 할때는 코드를 여러 영역으로 나눈 뒤 영역 안에서 이뤄지는 상호작용은 최대한 늘리고 영역 사이에서 이뤄지는 상호작용은 최소로 줄이는데 주력한다.(**결합도**를 낮추고 **응집도**를 높이고)
기능 편애는 흔히 어떤 함수가 자기가 속한 모듈의 함수나 데이터보다 다른 모듈의 함수나 데이터와 상호작용 할 일이 더 많을 때 풍기는 냄새이다.
**하수 추출하기**로 함수를 여러 조각으로 나눈 후 각각을 적합한 모듈로 옮기면 더 쉽게 해결되는 경우도 많다.

## 3.10 데이터 뭉치

몰려다니는 데이터 뭉치는 보금자리를 따로 마련해줘야 마땅하다.
가장 먼저 필드 형태의 데이터 뭉치를 찾아서 **클래스 추출하기**로 하나의 객채로 묶는다.
먼저 **매개변수 객체만들기**, **객체 통째로 넘기기**를 적용해 매개 변수 수를 줄여본다.

데이터 뭉치인지 판별하려면 값 하나를 삭제해보자. 그랬을 떄, 나머지 데이터만으로는 의미가 없다면 객체로 환생하길 갈망하는 데이터 뭉치라는 뜻이다.

## 3.11 기본형 집착

이 냄새는 문자열을 다루는 코드에서 특히 흔하다. 전화번호를 단순히 문자 집합으로만 표현하기엔 아쉬움이 많다.

**기본형을 객체로 바꾸기**를 적용할 수 있다. 기본형으로 표현된 코드가 조건부 동작을 제어하는 타입 코드로 쓰였다면 **타입코드를 서브클래스로 바꾸기**, **조건부 로직을 다형성으로 바꾸기**를 차례로 적용한다.

## 3.12 반복되는 switch문

중복되는 switch 문이 문제가 되는 이유는 조건절을 하나 추가 할 때마다 다른 switch문들도 모두 찾아서 함께 수정해야하기 떄문이다.
이때 **다형성**은 반복된 switch문이 내뿜는 사악한 기운을 제압해 최신 스타일로 바꿔주는 세련된 무기이다.

## 3.13 반복문

지금은 일급함수를 지원하는 언어가 많아졌기 때문에 **반복문을 파이프라인으로 바꾸기**를 적용해 시대에 걸맞지 않은 반복문을 제거할 수 있게 되었다.

## 3.14 성의없는 요소

본문 코드를 그대로 쓰는 것과 진배없는 함수도 있고, 실질적으로 메서드가 하나뿐 인 클래스도 있다.
이 제거 작업은 흔히 **함수 인라인하기**, **클래스 인라인하기**로 처리한다. 상속을 사용했땀ㄴ **계층 합치기**를 적용한다.

## 3.15 추측성 일반화

이 냄새는 '나중에 필요할거야'라는 생각으로 당장은 필요없는 모든 종류의 hooking 포인트와 특이 케이스 처리 로직을 작성해둔 코드에서 풍긴다.
당장 걸리적거리는 코드는 눈앞에서 치워버리자.

이는 **계층 합치기**, **함수 인라인하기, 클래스 인라인하기**로 삭제하며 사용되지 않는 매개변수는 **함수 선언 바꾸기**로 없앤다.
**죽은 코드를 제거**해야한다.

## 3.16 임시 필드

간혹 특정 상황에서만 값이 설정되는 필드를 가진 클래스도 있따.

## 3.17 메시지 체인

메시지 체인은 클라이언트가 한 객체를 통해 다른 객체를 얻은 뒤 방금 얻은 객체에 또 다른 객체를 요청하는 식으로, 다른 객체를 요청하는 작업이 연쇄적으로 이어지는 코드를 말한다.

## 3.18 중개자

객체의 대표적인 기능 하나로, 외부로부터 세부사항을 숨겨주는 캡슐화가 있다. 캡슐화하는 과정에서 위임이 자주 활용된다.
하지만 클래스가 제공하는 메서드 중 절반이 다른 클래스에 구현을 위임하는 등 지나칠 경우는 문제가 된다.
이럴 때는 **중개자 제거하기**를 활용해 실제로 일을 하는 객체와 직접 소통하게 한다.

## 3.19 내부자 거래

소프트웨어 개발자는 모듈 사이에 벽을 두껍게 세우기를 좋아하며, 그래서 모듈 사이의 데이터 거래가 많으면 '결합도'가 높아진다고 투덜댄다.

## 3.20 거대한 클래스

한 클래스가 너무 많은 일을 하려다 보면 필드 수가 상당히 늘어난다. 그리고 클래스에 필드가 너무 많으면 중복 코드가 생기기 쉽다.
이럴떄는 **클래스 추출하기**로 필드들 일부를 따로 묶는다. 일반적으로는 한 클래스 안에서 접두어나 접미어가 같은 필드들이 함께 추출할 후보이다. (비슷한 일을 하는 것)
**클래스 추출하기, 슈퍼 클래스 추출하기, 타입코드를 서브클래스로 바꾸기** 등을 활용해 여러 클래스로 분리한다.

## 3.21 서로 다른 인터페이스의 대안 클래스들

클래스를 사용할 때의 큰 장점은 필요에 따라 언제든 다른 클래스로 교체할 수 있다는 것이다.
교체하려면 인터페이스가 같아야 한다.
따라서 **함수 선언 바꾸기**로 메서드 시그니처를 일치시키고 **함수 옮기기**를 이용해 인터페이스가 같아질 때까지 필요한 동작들을 클래스 안으로 밀어넣는다. 그 후, 중복 코드가 생기면 **슈퍼 클래스 추출하기**를 적용할지 고려한다.

## 3.22 데이터 클래스

데이터 클래스란, 데이터 필드와 게터/세터 메서드로만 구성된 클래스를 말한다. 그저 데이터 저장용도로만 쓰이다보니, 다른 클래스가 너무 깊이까지 함부로 다룰 떄가 많다.
이런 클레스데 public 필드가 있다면 **레코드 캡슐화하기**로 숨겨야 한다.

## 3.23 상속 포기

상속포기 냄새는 서브 클레스가 부모의 동작은 필요로 하지만 인터페이스는 따르고 싶지 않을 때 특히 심하게 난다.
이럴 때엔ㄴ **서브 클래스를 위임으로 바꾸기, 슈퍼클래스를 위임으로 바꾸기** 를 활용해 아에 상속 메커니즘에서 벗어난다.

## 3.24 주석

주석은 악취가 아닌 향기를 입힌다. 문제는 주석을 탈취제 처럼 사용하는데 있다.
코드 블록이 하는 일에 주석을 남기고 싶다면, **함수 추출하기**를 적용한다.
여전히 설명이 필요하다면 **함수 선언 바꾸기**로 함수 이름을 바꾼다.

:::tip

주석을 남겨야겠다는 생각이 들면, 가장 먼저 주석이 필요없는 코드로 리팩터링해본다.

:::
